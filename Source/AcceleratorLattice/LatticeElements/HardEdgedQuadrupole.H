/* Copyright 2022 David Grote
 *
 * This file is part of WarpX.
 *
 * License: BSD-3-Clause-LBNL
 */
#ifndef WARPX_ACCELERATORLATTICE_LATTICEELEMENTS_HARDEDGEDQUADRUPOLE_H_
#define WARPX_ACCELERATORLATTICE_LATTICEELEMENTS_HARDEDGEDQUADRUPOLE_H_

#include "LatticeElementBase.H"
#include "HardEdged_K.H"

#include <AMReX_REAL.H>
#include <AMReX_ParmParse.H>
#include <AMReX_Vector.H>
#include <AMReX_GpuContainers.H>

#include <string>

// Specifies a field that models the field generated by a quadrupole lens,
// an axially uniform quadrupole field

struct HardEdgedQuadrupoleDevice;

struct HardEdgedQuadrupole
    : LatticeElementBase
{

    HardEdgedQuadrupole ();

    ~HardEdgedQuadrupole () = default;

    /**
     * \brief Read in an element and add it to the lists
     *
     * @param[in] pp_element The ParmParse instance to read in the data
     * @param[inout] z_location The current z location in the lattice
     */
    void
    AddElement (amrex::ParmParse & pp_element, amrex::ParticleReal & z_location);

    /**
     * \brief Write the element information to the device
     */
    void
    WriteToDevice ();

    /* The field gradients */
    /* On the host */
    std::vector<amrex::ParticleReal> h_dEdx;
    std::vector<amrex::ParticleReal> h_dBdx;
    /* On the device */
    amrex::Gpu::DeviceVector<amrex::ParticleReal> d_dEdx;
    amrex::Gpu::DeviceVector<amrex::ParticleReal> d_dBdx;

    /**
     * \brief Returns the device level instance with the lattice information
     */
    HardEdgedQuadrupoleDevice GetDeviceInstance () const;


};

// Instance that is trivially copyable to the device.

struct HardEdgedQuadrupoleDevice
{

    /**
     * \brief Initializes the data and pointer needed to reference the lattice element info
     *
     * @param[in] h_quad host level instance that this is associated with
     */
    void InitHardEdgedQuadrupoleDevice (HardEdgedQuadrupole const& h_quad);

    int nelements = 0;

    const amrex::ParticleReal* AMREX_RESTRICT d_zs_arr;
    const amrex::ParticleReal* AMREX_RESTRICT d_ze_arr;

    const amrex::ParticleReal* AMREX_RESTRICT d_dEdx_arr;
    const amrex::ParticleReal* AMREX_RESTRICT d_dBdx_arr;

    /**
     * \brief Fetch the field of the specified element at the given location
     *
     * @param[in] ielement the element number
     * @param[in] x, y, z the particle position in the lab frame
     * @param[in] zpvdt the estimated next particle z position, z + v*dt
     * @param[out] Ex, Ey, Bx, By the fetched field in the lab frame
     */
    AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE
    void get_field (const int ielement,
                    const amrex::ParticleReal x,
                    const amrex::ParticleReal y,
                    const amrex::ParticleReal z,
                    const amrex::ParticleReal zpvdt,
                    amrex::ParticleReal& Ex,
                    amrex::ParticleReal& Ey,
                    amrex::ParticleReal& Bx,
                    amrex::ParticleReal& By) const
    {

        // Calculate the residence correction, the fraction of the time step that the particle
        // spends inside the hard edged element.
        amrex::ParticleReal const frac = hard_edged_fraction(z, zpvdt, d_zs_arr[ielement], d_ze_arr[ielement]);

        amrex::ParticleReal dEdx = frac*d_dEdx_arr[ielement];
        amrex::ParticleReal dBdx = frac*d_dBdx_arr[ielement];

        Ex = +x*dEdx;
        Ey = -y*dEdx;
        Bx = +y*dBdx;
        By = +x*dBdx;

    }

};

#endif // WARPX_ACCELERATORLATTICE_LATTICEELEMENTS_HARDEDGEDQUADRUPOLE_H_
