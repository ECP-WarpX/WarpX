/* Copyright 2019 Luca Fedeli
 *
 * This file is part of WarpX.
 *
 * License: BSD-3-Clause-LBNL
 */
#ifndef WARPX_quantum_sync_engine_wrapper_h_
#define WARPX_quantum_sync_engine_wrapper_h_

#include "QedWrapperCommons.H"
#include "QedChiFunctions.H"

#include <AMReX_Array.H>
#include <AMReX_Vector.H>
#include <AMReX_Gpu.H>

#include <physics/quantum_sync/quantum_sync_engine_tables.hpp>
#include <physics/quantum_sync/quantum_sync_engine_core.hpp>

#include <string>
#include <vector>

// Aliases =============================
using QS_dndt_table_params =
    picsar::multi_physics::phys::quantum_sync::
    dndt_lookup_table_params<amrex::Real>;

using QS_dndt_table =
    picsar::multi_physics::phys::quantum_sync::
    dndt_lookup_table<
    amrex::Real,
    amrex::Gpu::ManagedVector<amrex::Real>>;

using QS_dndt_table_view = QS_dndt_table::view_type;

using QS_phot_em_table_params =
    picsar::multi_physics::phys::quantum_sync::
    photon_emission_lookup_table_params<amrex::Real>;

using QS_phot_em_table =
    picsar::multi_physics::phys::quantum_sync::
    photon_emission_lookup_table<
    amrex::Real,
    amrex::Gpu::ManagedVector<amrex::Real>>;

using QS_phot_em_table_view = QS_phot_em_table::view_type;

struct PicsarQuantumSyncCtrl
{
    QS_dndt_table_params dndt_params;
    QS_phot_em_table_params phot_em_params;
};

// Functors ==================================

// These functors allow using the core elementary functions of the library.
// They are generated by a factory class (QuantumSynchrotronEngine, see below).
// They can be included in GPU kernels.

/**
*  Functor to initialize the optical depth of leptons for the
*  Quantum Synchrotron process
*/
class QuantumSynchrotronGetOpticalDepth
{
public:
    /**
     * Constructor does nothing because optical depth initialization
     * does not require control parameters or lookup tables.
     */
    QuantumSynchrotronGetOpticalDepth ()
    {};

    /**
     * () operator is just a thin wrapper around a very simple function to
     * generate the optical depth. It can be used on GPU.
     */
    AMREX_GPU_HOST_DEVICE
    AMREX_FORCE_INLINE
    amrex::Real operator() () const noexcept
    {
        namespace pxr_qs = picsar::multi_physics::phys::quantum_sync;

        //A random number in [0,1) should be provided as an argument.
        return pxr_qs::get_optical_depth(amrex::Random());
    }
};
//____________________________________________

/**
 * Functor to evolve the optical depth of leptons due to the
 * Quantum Synchrotron process
 */
class QuantumSynchrotronEvolveOpticalDepth
{
public:

    /**
     * Constructor acquires pointers to control parameters and
     * lookup tables data.
     * lookup_table uses non-owning vectors under the hood. So no new data
     * allocations should be triggered on GPU
     */
    QuantumSynchrotronEvolveOpticalDepth(
        QS_dndt_table_view table_view):
        m_table_view{table_view}{};

    /**
     * Evolves the optical depth. It can be used on GPU.
     * @param[in] energy energy of the particle (SI units)
     * @param[in] chi_part quantum parameter of the particle
     * @param[in] dt timestep (SI units)
     * @param[in,out] opt_depth optical depth of the particle.
     * @return a flag which is 1 if chi_part was out of table.
     */
    AMREX_GPU_HOST_DEVICE
    AMREX_FORCE_INLINE
    int operator()(
        const amrex::Real energy, const amrex::Real chi_part,
        const amrex::Real dt, amrex::Real& opt_depth) const noexcept
    {
        namespace pxr_p = picsar::multi_physics::phys;
        namespace pxr_qs = picsar::multi_physics::phys::quantum_sync;

        const auto is_out = pxr_qs::evolve_optical_depth<
            amrex::Real,
            QS_dndt_table_view,
            pxr_p::unit_system::SI>(
                energy, chi_part, dt, opt_depth, m_table_view);

        return is_out;
    }

private:
    const QS_dndt_table_view m_table_view;
};

/**
 * Functor to generate a photon via the Quantum Synchrotron process
 * and to update momentum accordingly
 */
class QuantumSynchrotronPhotonEmission
{
public:
    /**
     * Constructor acquires pointers to control parameters and
     * lookup tables data.
     * lookup_table uses non-owning vectors under the hood. So no new data
     * allocations should be triggered on GPU
     */
    QuantumSynchrotronPhotonEmission (
        QS_phot_em_table_view table_view):
        m_table_view{table_view}{};

    /**
     * Generates photons according to Quantum Synchrotron process.
     * It can be used on GPU.
     * @param[in,out] px,py,pz momentum components of the lepton. They are modified (SI units)
     * @param[in] ex,ey,ez electric field components (SI units)
     * @param[in] bx,by,bz magnetic field components (SI units)
     * @param[out] g_px,g_py,g_pz momentum components of the generated photon (SI units)
     * @return a flag which is 1 if chi_photon was out of table
     */
    AMREX_GPU_HOST_DEVICE
    AMREX_FORCE_INLINE
    bool operator()(
    amrex::Real& px, amrex::Real& py, amrex::Real& pz,
    amrex::Real ex, amrex::Real ey, amrex::Real ez,
    amrex::Real bx, amrex::Real by, amrex::Real bz,
    amrex::Real& g_px, amrex::Real& g_py, amrex::Real& g_pz) const noexcept
    {
        namespace pxr_m = picsar::multi_physics::math;
        namespace pxr_p = picsar::multi_physics::phys;
        namespace pxr_qs = picsar::multi_physics::phys::quantum_sync;

        const auto rand_zero_one_minus_epsi = amrex::Random();

        const auto chi_particle = QedUtils::chi_ele_pos(
            px, py, pz, ex, ey, ez, bx, by, bz);

        auto momentum_particle = pxr_m::vec3<amrex::Real>{px, py, pz};
        auto momentum_photon = pxr_m::vec3<amrex::Real>();

        const auto is_out = pxr_qs::generate_photon_update_momentum<
            amrex::Real,
            QS_phot_em_table_view,
            pxr_p::unit_system::SI>(
                chi_particle, momentum_particle,
                rand_zero_one_minus_epsi,
                m_table_view,
                momentum_photon);

        px = momentum_particle[0];
        py = momentum_particle[1];
        pz = momentum_particle[2];
        g_px = momentum_photon[0];
        g_py = momentum_photon[1];
        g_pz = momentum_photon[2];

        return is_out;
    }

private:
    const QS_phot_em_table_view m_table_view;

};

// Factory class =============================

/**
 * Wrapper for the Quantum Synchrotron engine of the PICSAR library
 */
class QuantumSynchrotronEngine
{
public:
    /**
     * Constructor requires no arguments.
     */
    QuantumSynchrotronEngine ();

    /**
     * Builds the functor to initialize the optical depth
     */
    QuantumSynchrotronGetOpticalDepth build_optical_depth_functor ();

    /**
     * Builds the functor to evolve the optical depth
     */
    QuantumSynchrotronEvolveOpticalDepth build_evolve_functor ();

    /**
     * Builds the functor to generate photons
     */
    QuantumSynchrotronPhotonEmission build_phot_em_functor ();

    /**
     * Checks if the optical tables are properly initialized
     */
    bool are_lookup_tables_initialized () const;

    /**
     * Export lookup tables data into a raw binary Vector
     * @return the data in binary format. The Vector is empty if tables were
     * not previously initialized.
     */
    std::vector<char> export_lookup_tables_data () const;

    /**
     * Init lookup tables from raw binary data.
     * @param[in] raw_data a vector of char
     * @return true if it succeeds, false if it cannot parse raw_data
     */
    bool init_lookup_tables_from_raw_data (const std::vector<char>& raw_data);

    /**
     * Init lookup tables using built-in (low resolution) tables
     */
    void init_builtin_tables();

    /**
     * Computes the lookup tables. It does nothing unless WarpX is compiled with QED_TABLE_GEN=TRUE
     * @param[in] ctrl control params to generate the tables
     */
    void compute_lookup_tables (PicsarQuantumSyncCtrl ctrl);

    /**
     * gets default values for the control parameters
     * @return default control params to generate the tables
     */
    PicsarQuantumSyncCtrl get_default_ctrl() const;

private:
    bool m_lookup_tables_initialized = false;

    QS_dndt_table m_dndt_table;
    QS_phot_em_table m_phot_em_table;

    void init_builtin_dndt_table();
    void init_builtin_phot_em_table();
};

//============================================

#endif //WARPX_quantum_sync_engine_wrapper_h_
