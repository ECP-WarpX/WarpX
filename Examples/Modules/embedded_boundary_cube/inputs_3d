#stop_time = 1.3342563807926085e-08
max_step = 100
amr.n_cell = 48 48 48
amr.max_grid_size = 128
amr.max_level = 0

geometry.coord_sys   = 0
geometry.is_periodic = 0 0 0
geometry.prob_lo     = -0.8 -0.8 -0.8
geometry.prob_hi     =  0.8  0.8  0.8
warpx.do_pml = 1
warpx.const_dt = 1e-6
warpx.cfl = 1

#salgo.maxwell_solver = ect

eb2.init_em_field = false
eb2.geom_type = cane
#eb2.box_lo = -0.53 -0.53 -0.53
#eb2.box_hi = 0.53 0.53 0.53
#eb2.box_has_fluid_inside = true
# Alternatively one could use parser to build EB
# Note that for amrex EB implicit function, >0 is covered, =0 is boundary and <0 is regular.
my_constants.xmin = -0.53
my_constants.ymin = -0.53
my_constants.zmin = -0.53
my_constants.xmax = 0.53
my_constants.ymax = 0.53
my_constants.zmax = 0.53
my_constants.pi = 3.141592653589793
my_constants.theta = pi/8

warpx.eb_implicit_function = "max(max(max(x+xmin,-(x+xmax)), max(y*cos(-theta)-z*sin(-theta)+ymin,-(y*cos(-theta)-z*sin(-theta)+ymax))), max(y*sin(-theta)+z*cos(-theta)+zmin,-(y*sin(-theta)+z*cos(-theta)+zmax)))"

warpx.B_ext_grid_init_style = parse_B_ext_grid_function
my_constants.m = 0
my_constants.n = 1
my_constants.p = 1
my_constants.Lx = 1.06
my_constants.Ly = 1.06
my_constants.Lz = 1.06
my_constants.x_cent = 0.
my_constants.y_cent = 0.
my_constants.z_cent = 0.
my_constants.h_2 = (m * pi / Lx) ** 2 + (n * pi / Ly) ** 2 + (p * pi / Lz) ** 2
my_constants.mu_0 = 1.25663706212e-06

#my_constants.ddx_u = 0.0125
#my_constants.ddy_u = 0.0125
#my_constants.ddz_u = 0.0125
#my_constants.ddx_d = 0.0125
#my_constants.ddy_d = 0.0125
#my_constants.ddz_d = 0.0125

warpx.Bx_external_grid_function(x,y,z) = -2/h_2 * (m * pi / Lx) * (p * pi / Lz) * sin(m * pi / Lx * (x - Lx / 2 - x_cent)) * cos(n * pi / Ly * (y*cos(-theta)-z*sin(-theta) - Ly / 2 - y_cent)) * cos(p * pi / Lz * (y*sin(-theta)+z*cos(-theta) - Lz / 2 - z_cent))*mu_0 #*(x>-Lx/2+x_cent+x_cent-ddx_d)*(x<Lx/2+x_cent+ddx_u)*(y*cos(-theta)-z*sin(-theta)>-Ly/2+y_cent-ddy_d)*(y*cos(-theta)-z*sin(-theta)<Ly/2+y_cent+ddy_u)*(y*sin(-theta)+z*cos(-theta)>-Lz/2+z_cent-ddz_d)*(y*sin(-theta)+z*cos(-theta)<Lz/2+z_cent+ddz_u)
warpx.By_external_grid_function(x,y,z) = -2/h_2 * (n * pi / Ly) * (p * pi / Lz) * cos(m * pi / Lx * (x - Lx / 2 - x_cent)) * sin(n * pi / Ly * (y*cos(-theta)-z*sin(-theta) - Ly / 2 - y_cent)) * cos(p * pi / Lz * (y*sin(-theta)+z*cos(-theta) - Lz / 2 - z_cent))*mu_0 #*(x>-Lx/2+x_cent+x_cent-ddx_d)*(x<Lx/2+x_cent+ddx_u)*(y*cos(-theta)-z*sin(-theta)>-Ly/2+y_cent-ddy_d)*(y*cos(-theta)-z*sin(-theta)<Ly/2+y_cent+ddy_u)*(y*sin(-theta)+z*cos(-theta)>-Lz/2+z_cent-ddz_d)*(y*sin(-theta)+z*cos(-theta)<Lz/2+z_cent+ddz_u)
warpx.Bz_external_grid_function(x,y,z) = cos(m * pi / Lx * (x - Lx / 2 - x_cent)) * cos(n * pi / Ly * (y*cos(-theta)-z*sin(-theta) - Ly / 2 - y_cent)) * sin(p * pi / Lz * (y*sin(-theta)+z*cos(-theta) - Lz / 2 - z_cent))*mu_0 #*(x>-Lx/2+x_cent-ddx_d)*(x<Lx/2+x_cent+ddx_u)*(y*cos(-theta)-z*sin(-theta)>-Ly/2+y_cent-ddy_d)*(y*cos(-theta)-z*sin(-theta)<Ly/2+y_cent+ddy_u)*(y*sin(-theta)+z*cos(-theta)>-Lz/2+z_cent-ddz_d)*(y*sin(-theta)+z*cos(-theta)<Lz/2+z_cent+ddz_u)

diagnostics.diags_names = diag1
diag1.intervals = 1
diag1.diag_type = Full
diag1.fields_to_plot = Ex Ey Ez Bx By Bz
